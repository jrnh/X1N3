	int random( const int & min, const int & max ) noexcept
	{
		return rand( ) % ( max - min + 1 ) + min;
	}

	void remapping( RecvProxyData * data, view_model_t * entity )
	{
		const auto local_player = entity_t::get<player_t>( ctx::csgo.engine->GetLocalPlayer( ) );
		if ( !local_player || !local_player->is_alive( ) )
			return;

		const auto owner = entity_t::get( entity->get_owner( ) );
		if ( !owner )
			return;

		const auto view_model_weapon = entity_t::get<weapon_t>( entity->get_weapon( ) );
		if ( !view_model_weapon )
			return;

		auto & sequence = data->m_Value.m_Int;

		int original_activity = entity->get_sequence_activity( sequence );

		int new_activity = 1;
		int num = 0;

		for (size_t i = 0; i < 20; i++)
		{
			int temp_actitivity = entity->get_sequence_activity( i );
			if ( original_activity != -1 && original_activity == temp_actitivity || original_activity == -1 && temp_actitivity == 213 )
			{
				new_activity = i;
				for ( size_t t = 0; t < 4; t++ )
					if ( entity->get_sequence_activity( i + t ) == temp_actitivity )
						num++;
				break;
			}
		}

		if ( original_activity == -1 && new_activity == 1 )
			new_activity = sequence;

		if ( !num )
			sequence = new_activity;
		else
			sequence = random( new_activity, new_activity + num - 1 );

		entity->send_view_model_matcing_sequence( sequence );
	}

	void sequence_fix( const RecvProxyData * const_data, void * structure, void * out )
	{
		const auto data = const_cast<RecvProxyData *>( const_data );
		const auto view_model = static_cast<view_model_t *>( structure );

		remapping( data, view_model );

		m_old_proxy( data, structure, out );
	}

	void init( )
	{
		for ( auto class_list = ctx::csgo.client->GetAllClasses( ); class_list; class_list = class_list->m_pNext )
		{
			if ( HASH( class_list->m_pNetworkName ) != CT_HASH( "CBaseViewModel" ) )
				continue;

			const auto table = class_list->m_pRecvTable;

			for ( auto i = 0; i < table->m_nProps; i++ )
			{
				const auto prop = &table->m_pProps[ i ];
				if ( !prop || HASH( prop->m_pVarName ) != CT_HASH( "m_nSequence" ) )
					continue;

				m_sequence_prop = prop;
				m_old_proxy = prop->m_ProxyFn;
				prop->m_ProxyFn = sequence_fix;

				break;
			}
		}
	}